# 第3章 数値

Haskellに独特なのは、`Integer` と 


> Num クラスは Eq クラスとShowクラスの両方のサブクラスである

GHC 7.4 からちがう

```haskell
Prelude> :i Num
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num Word -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Double -- Defined in ‘GHC.Float’
```

# 3.2 そのたの数値型クラス

> Num クラスには 2つのサブクラスがある。実数と分数である

分数？有理数じゃなくって？ …Raitional にたいして Fractional を分数を訳したとのこと。いい訳し方あったら教えてとのこと。

fst snd ふすと・すんど と読んでた。

フロア  `|_ x _|`


float と double が enumu に入っているのが、ぎょっとする。

でも列挙可能？やってみると、

```haskell
Prelude> [1.0 .. 100]
[1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18.0,19.0,20.0,21.0,22.0,23.0,24.0,25.0,26.0,27.0,28.0,29.0,30.0,31.0,32.0,33.0,34.0,35.0,36.0,37.0,38.0,39.0,40.0,41.0,42.0,43.0,44.0,45.0,46.0,47.0,48.0,49.0,50.0,51.0,52.0,53.0,54.0,55.0,56.0,57.0,58.0,59.0,60.0,61.0,62.0,63.0,64.0,65.0,66.0,67.0,68.0,69.0,70.0,71.0,72.0,73.0,74.0,75.0,76.0,77.0,78.0,79.0,80.0,81.0,82.0,83.0,84.0,85.0,86.0,87.0,88.0,89.0,90.0,91.0,92.0,93.0,94.0,95.0,96.0,97.0,98.0,99.0,100.0]
Prelude> :t [1.0 .. 100]
[1.0 .. 100] :: (Enum t, Fractional t) => [t]
```

列挙ではなく等差数列

```haskell
Prelude> [1.1 .. 100]
[1.1,2.1,3.1,4.1,5.1,6.1,7.1,8.1,9.1,10.1,11.1,12.1,13.1,14.1,15.1,16.1,17.1,18.1,19.1,20.1,21.1,22.1,23.1,24.1,25.1,26.1,27.1,28.1,29.1,30.1,31.1,32.1,33.1,34.1,35.1,36.1,37.1,38.1,39.1,40.1,41.1,42.1,43.1,44.1,45.1,46.1,47.1,48.1,49.1,50.1,51.1,52.1,53.1,54.1,55.1,56.1,57.1,58.1,59.1,60.1,61.1,62.1,63.1,64.1,65.1,66.1,67.1,68.1,69.1,70.1,71.1,72.1,73.1,74.1,75.1,76.1,77.1,78.1,79.1,80.1,81.1,82.1,83.1,84.1,85.1,86.1,87.1,88.1,89.1,90.1,91.1,92.1,93.1,94.1,95.1,96.1,97.1,98.1,99.1,100.1]
```

なんぞ!? 100を超える(^^;

```haskell
Prelude> [1.99 .. 100]
[1.99,2.99,3.99,4.99,5.99,6.99,7.99,8.99,9.99,10.99,11.99,12.99,13.99,14.99,15.99,16.990000000000002,17.990000000000002,18.990000000000002,19.990000000000002,20.990000000000002,21.990000000000002,22.990000000000002,23.990000000000002,24.990000000000002,25.990000000000002,26.990000000000002,27.990000000000002,28.990000000000002,29.990000000000002,30.990000000000002,31.990000000000002,32.99,33.99,34.99,35.99,36.99,37.99,38.99,39.99,40.99,41.99,42.99,43.99,44.99,45.99,46.99,47.99,48.99,49.99,50.99,51.99,52.99,53.99,54.99,55.99,56.99,57.99,58.99,59.99,60.99,61.99,62.99,63.99,64.99000000000001,65.99000000000001,66.99000000000001,67.99000000000001,68.99000000000001,69.99000000000001,70.99000000000001,71.99000000000001,72.99000000000001,73.99000000000001,74.99000000000001,75.99000000000001,76.99000000000001,77.99000000000001,78.99000000000001,79.99000000000001,80.99000000000001,81.99000000000001,82.99000000000001,83.99000000000001,84.99000000000001,85.99000000000001,86.99000000000001,87.99000000000001,88.99000000000001,89.99000000000001,90.99000000000001,91.99000000000001,92.99000000000001,93.99000000000001,94.99000000000001,95.99000000000001,96.99000000000001,97.99000000000001,98.99000000000001,99.99000000000001]
```

偶数まるめ、で丸めると 100になる場合は超えるみたい。

```haskell
Prelude> [1.6 .. 100]
[1.6,2.6,3.6,4.6,5.6,6.6,7.6,8.6,9.6,10.6,11.6,12.6,13.6,14.6,15.6,16.6,17.6,18.6,19.6,20.6,21.6,22.6,23.6,24.6,25.6,26.6,27.6,28.6,29.6,30.6,31.6,32.6,33.6,34.6,35.6,36.6,37.6,38.6,39.6,40.6,41.6,42.6,43.6,44.6,45.6,46.6,47.6,48.6,49.6,50.6,51.6,52.6,53.6,54.6,55.6,56.6,57.6,58.6,59.6,60.6,61.6,62.6,63.6,64.6,65.6,66.6,67.6,68.6,69.6,70.6,71.6,72.6,73.6,74.6,75.6,76.6,77.6,78.6,79.6,80.6,81.6,82.6,83.6,84.6,85.6,86.6,87.6,88.6,89.6,90.6,91.6,92.6,93.6,94.6,95.6,96.6,97.6,98.6,99.6]
Prelude> [1.51 .. 100]
[1.51,2.51,3.51,4.51,5.51,6.51,7.51,8.51,9.51,10.51,11.51,12.51,13.51,14.51,15.51,16.509999999999998,17.509999999999998,18.509999999999998,19.509999999999998,20.509999999999998,21.509999999999998,22.509999999999998,23.509999999999998,24.509999999999998,25.509999999999998,26.509999999999998,27.509999999999998,28.509999999999998,29.509999999999998,30.509999999999998,31.509999999999998,32.51,33.51,34.51,35.51,36.51,37.51,38.51,39.51,40.51,41.51,42.51,43.51,44.51,45.51,46.51,47.51,48.51,49.51,50.51,51.51,52.51,53.51,54.51,55.51,56.51,57.51,58.51,59.51,60.51,61.51,62.51,63.51,64.50999999999999,65.50999999999999,66.50999999999999,67.50999999999999,68.50999999999999,69.50999999999999,70.50999999999999,71.50999999999999,72.50999999999999,73.50999999999999,74.50999999999999,75.50999999999999,76.50999999999999,77.50999999999999,78.50999999999999,79.50999999999999,80.50999999999999,81.50999999999999,82.50999999999999,83.50999999999999,84.50999999999999,85.50999999999999,86.50999999999999,87.50999999999999,88.50999999999999,89.50999999999999,90.50999999999999,91.50999999999999,92.50999999999999,93.50999999999999,94.50999999999999,95.50999999999999,96.50999999999999,97.50999999999999,98.50999999999999,99.50999999999999]
```

## 3.3 床値の計算

### 二分探索


休み時間に何故か超越数のお話に。
（どうHaskellで定義する？）

## 3.4 自然数

GHC 7.10.1 で Numeric.Natural

```haskell
Prelude> import Numeric.Natural
Prelude Numeric.Natural> :info Natural 
data Natural
  = GHC.Natural.NatS# integer-gmp-1.0.0.1:GHC.Integer.Type.GmpLimb#
  | GHC.Natural.NatJ# {-# UNPACK #-}integer-gmp-1.0.0.1:GHC.Integer.Type.BigNat
  	-- Defined in ‘GHC.Natural’
instance Enum Natural -- Defined in ‘GHC.Natural’
instance Eq Natural -- Defined in ‘GHC.Natural’
instance Integral Natural -- Defined in ‘GHC.Natural’
instance Num Natural -- Defined in ‘GHC.Natural’
instance Ord Natural -- Defined in ‘GHC.Natural’
instance Read Natural -- Defined in ‘GHC.Natural’
instance Real Natural -- Defined in ‘GHC.Natural’
instance Show Natural -- Defined in ‘GHC.Natural’
```

実行時エラーになる。

```haskell
Prelude Numeric.Natural> 0 - 1 :: Natural
*** Exception: arithmetic underflow
```

依存型ないとおいしくないよね、というお話で盛り上がる。

儀数（ぱーしゃるなんばー）

## 3.5 練習問題

### 練習問題A

```haskell
Prelude > -2 + 3
1
Prelude Numeric.Natural> 3 + -2

<interactive>:34:1: error:
    Precedence parsing error
        cannot mix ‘+’ [infixl 6] and prefix `-' [infixl 6] in the same infix expression
Prelude w> 3 + (-2)
1
Prelude > subtract 2 3
1
Prelude > 2 + subtract 3

<interactive>:37:1: error:
    • Non type-variable argument in the constraint: Num (a -> a)
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a. (Num (a -> a), Num a) => a -> a
```


### 練習問題B

```haskell
Prelude> :t (^)
(^) :: (Num a, Integral b) => a -> b -> a
Prelude> :t (^^)
(^^) :: (Integral b, Fractional a) => a -> b -> a
Prelude> :t (**)
(**) :: Floating a => a -> a -> a
```


Integral は Inte的な型クラス (Integer や Intがインスタンスである)


#### 余談1

GHCi からインポートしたモジュールを除去する方法は

```haskell
Prelude> import Numeric.Natural 
Prelude Numeric.Natural> :m - Numeric.Natural 
Prelude> 
```

```haskell
Prelude> :m - Prelude 
```

Prelude は引けない。

hiddingでimport すると Prelude Prelude になる。

```haskell
Prelude> import Prelude hiding ((^))
Prelude Prelude> :t (^)
(^) :: (Num a, Integral b) => a -> b -> a
```

こうなると引ける

```haskell
Prelude Prelude> :m - Prelude 
Prelude> 
```

#### 余談2

ghci で複数行書く

```haskell
Prelude> :set +m
Prelude> let x = 1
Prelude|             + 2
Prelude|     y = "abc"
Prelude|     z = 'x'
Prelude| in
Prelude|     show x ++ y ++ [z]
"3abcx"
```

### 練習問題C


ghci ではデフォルティングしている。(stackも？）
fromIntegral の型が定まるのはそのせい（これはよくない）

コンパイルするときは `-Wtype-defaults` をつけないとダメ。

### 練習問題D

```haskell
Prelude> floor (-3.14)
-4
Prelude> round (-3.14)
-3
```


### 練習問題E

最初は 1/100万 をεに使用した

```haskell
sqrt' :: Float -> Float
sqrt' x = until goodEnough improove 1
  where
    goodEnough y = abs (y ^^ (2 :: Int) -x) < epsilon * x
    improove y  = (y + x / y) / 2
    epsilon     = 10 ^^ (-6 :: Int)
```

マシンεを求めてみた

```haskell
sqrt' :: Float -> Float
sqrt' x = until goodEnough improove 1
  where
    goodEnough y = abs (y ^^ (2 :: Int) -x) <= 2 * epsilon1 * x -- それはそれとして、近づいているかをチェックするときに2じょう しているので、2*epsilon
    improove y   = (y + x / y) / 2
    epsilon1     = 2 * until (\x -> 1 + x == 1) (/ 2) 1  　　　-- マシンイプシロンは足しても増えないので、ほんのちょっとだけ大きくするので * 2
```

結果を確認


```haskell
*Main> map sqrt [(1.0 :: Float) .. (10.0 :: Float)]
[1.0,1.4142135,1.7320508,2.0,2.236068,2.4494898,2.6457512,2.828427,3.0,3.1622777]

*Main> map sqrt' [1.0 .. 10.0]
[1.0,1.4142135,1.7320509,2.0,2.236068,2.4494896,2.6457515,2.828427,3.0,3.1622777]
```

#### 余談

```haskell
import Debug.Trace
import Control.Monad
```

で、

```haskell
(join traceShow hoge))
```

でトレースできる。便利

(εが小さ過ぎて sqrt' 6 が非停止に陥ったときデバッグに用いた。goodEnough を以下のように修正する)

```haskell
goodEnough y = abs ((join traceShow y) ^^ (2 :: Int) -x) <= 2 * epsilon1 * x
```

```haskell
*Main> sqrt' 3
1.0
2.0
1.75
1.7321429
1.7320509
1.7320509
*Main> sqrt' 6
1.0
3.5
2.607143
2.4542565
2.4494944
2.4494896
2.4494896
```

### 練習問題G

作った。 Ord は、`compare` か `<=` のどちらかをインプリすればいい。

```haskell
*Main> fromInteger 5 :: Nat
Succ (Succ (Succ (Succ (Succ Zero))))
```

```haskell
*Main> divMod' (fromInteger 5) (fromInteger 3)
(Succ Zero,Succ (Succ Zero))
```

#### 追記

ゼロ除算すると、止まらなくなる。それもまたボトム。

